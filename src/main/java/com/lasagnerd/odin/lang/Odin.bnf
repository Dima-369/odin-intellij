{
  parserClass="com.lasagnerd.odin.lang.OdinParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Odin"
  psiImplClassSuffix="Impl"
  psiPackage="com.lasagnerd.odin.lang.psi"
  psiImplPackage="com.lasagnerd.odin.lang.psi.impl"

  elementTypeHolderClass="com.lasagnerd.odin.lang.psi.OdinTypes"
  elementTypeClass="com.lasagnerd.odin.lang.psi.OdinElementType"
  tokenTypeClass="com.lasagnerd.odin.lang.psi.OdinTokenType"

  tokens=[
        LINE_COMMENT='regexp://[^\r\n]*'
        BLOCK_COMMENT='regexp:/\*[\s\S]*?\*/'

        PACKAGE='regexp:package'
        IMPORT='regexp:import'
        PROC='regexp:proc'
        RETURN='regexp:return'
        DEFER='regexp:defer'
        STRUCT='regexp:struct'
        FOR='regexp:for'
        IN='regexp:in'
        NOT_IN='regexp:not_in'
        DO='regexp:do'
        IF='regexp:if'
        ELSE='regexp:else'
        SWITCH='regexp:switch'
        CASE='regexp:case'
        FALLTHROUGH='regexp:fallthrough'
        TRUE='regexp:true'
        FALSE='regexp:false'
        WHEN='regexp:when'
        BREAK='regexp:break'
        CONTINUE='regexp:continue'
        NIL='regexp:nil'
        TRIPLE_DASH='regexp:---'
        OR_ELSE='regexp:or_else'
        OR_RETURN='regexp:or_return'
        FOREIGN='regexp:foreign'
        CAST='regexp:cast'
        AUTO_CAST='regexp:AUTO_CAST'
        TRANSMUTE='regexp:TRANSMUTE'
        DYNAMIC='regexp:dynamic'
        BIT_SET='regexp:bit_set'
        MAP='regexp:map'
        USING='regexp:using'
        ENUM='regexp:enum'
        UNION='regexp:union'
        DISTINCT='regexp:distinct'

        IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DQ_STRING_LITERAL='regexp:"[^"]*"'
        SQ_STRING_LITERAL="regexp:'[^']+?'"
        INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*'
        INTEGER_HEX_LITERAL='regexp:0x[0-9a-fA-F][0-9a-fA-F_]*'
        INTEGER_OCT_LITERAL='regexp:0o[0-7][0-7_]*'
        INTEGER_BIN_LITERAL='regexp:0b[01][01_]*'
        FLOAT_DEC_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*'
        COMPLEX_FLOAT_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*[ijk]'
        COMPLEX_INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*[ijk]'

        EQ='regexp:='
        COLON='regexp::'

        LBRACE='regexp:\{'
        RBRACE='regexp:}'
        LPAREN='regexp:\('
        RPAREN='regexp:\)'

        LBRACKET='regexp:\['
        RBRACKET='regexp:]'
        HASH='regexp:#'

        DOT='regexp:\.'
        ARROW='regexp:->'
        COMMA='regexp:,'
        SEMICOLON='regexp:;'
        QUESTION='regexp:\?'
        CARET='regexp:\^'
        AT='regexp:@'

        // Operators
        EQEQ='regexp:=='
        NEQ='regexp:!='
        LT='regexp:<'
        GT='regexp:>'
        LTE='regexp:<='
        GTE='regexp:>='

        // Boolean operators
        ANDAND='regexp:&&'
        OROR='regexp:\|\|'
        NOT='regexp:!'
        ANDNOT='regexp:&~'


        // Arithmetic operators
        PLUS='regexp:\+'
        MINUS='regexp:-'
        STAR='regexp:\*'
        DIV='regexp:/'
        MOD='regexp:%'
        REMAINDER='regexp:%%'

        // Bitwise operators
        AND='regexp:&'
        PIPE='regexp:\|'
        TILDE='regexp:~'
        LSHIFT='regexp:<<'
        RSHIFT='regexp:>>'


        // Assignment operators
        PLUS_EQ='regexp:\+='
        MINUS_EQ='regexp:-='
        STAR_EQ='regexp:\*='
        DIV_EQ='regexp:/='
        MOD_EQ='regexp:%='
        REMAINDER_EQ='regexp:%%='
        AND_EQ='regexp:&='
        OR_EQ='regexp:\|='
        XOR_EQ='regexp:~='
        ANDAND_EQ='regexp:&&='
        OROR_EQ='regexp:\|\|='
        LSHIFT_EQ='regexp:<<='
        RSHIFT_EQ='regexp:>>='

        // Range Operators
        RANGE = 'regexp:\.\.'
        RANGE_INCLUSIVE='regexp:\.\.='
        RANGE_EXCLUSIVE='regexp:\.\.<'

        WHITE_SPACE='regexp:\s+|\r?\n'
  ]

  extends('.*_expression') = expression
}

odinFile ::= packageDeclaration globalStatement*
packageDeclaration ::= PACKAGE IDENTIFIER
importDeclaration ::= IMPORT IDENTIFIER? DQ_STRING_LITERAL

globalStatement ::= importDeclaration
                | enumDeclaration
                | unionDeclaration
                | typeAliasDeclaration
                | foreignImportDeclaration
                | structDeclaration
                | bitsetDeclaration
                | constantInitialization
                | variableDeclaration
                | variableInitialization
                | procedureOverloadStatement
                | procedureDeclaration
                | foreignStatement


foreignImportDeclaration ::= FOREIGN IMPORT ( IDENTIFIER DQ_STRING_LITERAL | LBRACE DQ_STRING_LITERAL (COMMA DQ_STRING_LITERAL)* RBRACE)

statement  ::= variableInitialization
               | enumDeclaration
               | variableDeclaration
               | constantInitialization
               | procedureOverloadStatement
               | procedureDeclaration
               | bitsetDeclaration
               | forStatement
               | ifStatement
               | whenStatement
               | switchStatement
               | deferStatement
               | returnStatement
               | breakStatement
               | continueStatement
               | attributeStatement
               | usingStatement

foreignStatement ::= attributeStatement? FOREIGN IDENTIFIER foreignBlock
foreignBlock ::= LBRACE (foreignProcedureDeclaration|variableDeclaration) RBRACE
foreignProcedureDeclaration ::= attributeStatement? IDENTIFIER COLON COLON PROC string_literal? LPAREN parameterList* RPAREN (ARROW returnType)? TRIPLE_DASH

// Attributes
attributeStatement ::=  AT IDENTIFIER
                       | AT LPAREN IDENTIFIER (EQ (literal_expression | IDENTIFIER))? RPAREN
// Struct
structDeclaration ::= attributeStatement? IDENTIFIER COLON COLON STRUCT tag? structSpec
structSpec ::= LBRACE (fieldDeclaration COMMA)* RBRACE
fieldDeclaration ::= USING? IDENTIFIER (COMMA IDENTIFIER)* COLON typeDefinition_expression

// Enum
enumDeclaration ::= attributeStatement? IDENTIFIER COLON COLON ENUM enumSpec
enumSpec ::= LBRACE (IDENTIFIER COMMA)* RBRACE

// Union
unionDeclaration ::= attributeStatement? IDENTIFIER COLON COLON UNION tag? unionSpec
unionSpec ::= LBRACE typeDefinition_expression (COMMA typeDefinition_expression)* RBRACE



// Bit Set
bitsetDeclaration ::= IDENTIFIER COLON COLON BIT_SET LBRACKET expression [SEMICOLON typeDefinition_expression] RBRACKET

// Procedure
procedureDeclaration ::= attributeStatement? IDENTIFIER COLON COLON PROC string_literal? LPAREN parameterList* RPAREN (ARROW returnType)? block

returnType          ::= IDENTIFIER | LPAREN returnParameterList RPAREN
returnParameterList ::= returnParameter (COMMA returnParameter)*
returnParameter     ::= (identifierList COLON)? typeDefinition_expression

returnStatement ::= RETURN returnArgumentList?
private returnArgumentList ::= expression (COMMA expression)*

usingStatement ::= USING expression

// Procedure overloading
procedureOverloadStatement ::= IDENTIFIER COLON COLON PROC LBRACE IDENTIFIER (COMMA IDENTIFIER)* RBRACE

// Variables and constants
typeDefinition_expression   ::= CARET? typeType
private typeType ::= mapType|matrixType|bitSetType|arrayType|IDENTIFIER
bitSetType       ::= BIT_SET LBRACKET expression [SEMICOLON identifier_expression] RBRACKET
mapType          ::= MAP LBRACKET typeDefinition_expression RBRACKET typeDefinition_expression
matrixType       ::= MATRIX LBRACKET expression COMMA expression RBRACKET typeDefinition_expression
arrayType        ::= LBRACKET [QUESTION|DYNAMIC|expression] RBRACKET typeDefinition_expression


constantInitialization ::= IDENTIFIER COLON typeDefinition_expression? COLON (expression|tag)
typeAliasDeclaration ::= IDENTIFIER COLON COLON DISTINCT? typeDefinition_expression

variableInitialization ::= identifierList COLON EQ expressionsList
                           | attributeStatement? IDENTIFIER COLON typeDefinition_expression? EQ expression
identifierList ::= IDENTIFIER (COMMA IDENTIFIER)*

assignmentStatement ::=  leftHandExpressionList assignmentOperator expressionsList
leftHandExpressionList ::= leftHandExpression (COMMA leftHandExpression)*
leftHandExpression ::= matrixIndex_expression
    | arrayIndex_expression
    | arraySlice_expression
    | reference_expression
    | identifier_expression
    | dereference_expression

expressionsList ::= expression (COMMA expression)*

assignmentOperator ::= EQ
                       | PLUS_EQ
                       | MINUS_EQ
                       | STAR_EQ
                       | DIV_EQ
                       | MOD_EQ
                       | REMAINDER_EQ
                       | AND_EQ
                       | OR_EQ
                       | XOR_EQ
                       | ANDAND_EQ
                       | OROR_EQ
                       | LSHIFT_EQ
                       | RSHIFT_EQ

variableDeclaration ::= attributeStatement? IDENTIFIER COLON typeDefinition_expression

// Parameters for procedures and assignments
parameterList ::= parameter (COMMA parameter)*
parameter ::= parameterDeclaration
              | parameterInitialization
              | variadicParameter

private parameterDeclaration ::= USING? IDENTIFIER (COMMA IDENTIFIER)* COLON typeDefinition_expression
private parameterInitialization ::= IDENTIFIER COLON EQ expression
private variadicParameter ::= IDENTIFIER COLON RANGE typeDefinition_expression

// Function calls
argumentList  ::= argument (COMMA argument)*
namedArgument ::= IDENTIFIER EQ expression { extends = argument}
argument      ::= namedArgument
                  | unnamedArgument
unnamedArgument ::= expression { extends = argument}

call_expression ::= caller LPAREN argumentList? RPAREN
caller ::= identifier_expression
           | parenthesized_expression
binary_expression ::= expression binaryOperator expression
binaryOperator ::= PLUS
                   | MINUS
                   | STAR
                   | DIV
                   | MOD
                   | REMAINDER
                   | PIPE
                   | TILDE
                   | ANDAND
                   | ANDNOT
                   | AND
                   | OROR
                   | LSHIFT
                   | RSHIFT
                   | EQEQ
                   | NEQ
                   | LT
                   | GT
                   | LTE
                   | GTE
                   | RANGE
                   | RANGE_INCLUSIVE
                   | RANGE_EXCLUSIVE
                   | OR_ELSE
                   | IN
                   | NOT_IN

parenthesized_expression ::= LPAREN expression RPAREN

// Does it make sense to have literal expressions in the chain?

expression ::= implicitSelector_expression
               | reference_expression
               | parenthesized_expression
               | call_expression
               | binary_expression
               | unary_expression
               | or_return_expression
               | set_expression
               | arraySlice_expression
               | arrayIndex_expression
               | literal_expression
               | dereference_expression
               | uninitialized_expression
               | cast_expression
               | transmute_expression
               | auto_cast_expression
               | nil_expression
               | identifier_expression
               | typeDefinition_expression


//ternary_cond_expression ::= expression QUESTION expression COLON expression
//ternary_if_expression ::= expression IF expression ELSE expression
//ternary_when_expression ::= expression WHEN expression ELSE expression

cast_expression ::= CAST LPAREN typeDefinition_expression RPAREN expression
transmute_expression ::= TRANSMUTE LPAREN typeDefinition_expression RPAREN expression
auto_cast_expression ::= AUTO_CAST expression

nil_expression ::= NIL
uninitialized_expression ::= TRIPLE_DASH
identifier_expression ::= IDENTIFIER
set_expression ::= LBRACE [expression (COMMA expression)*] RBRACE
reference_expression ::= expression DOT expression
implicitSelector_expression ::= DOT expression
dereference_expression ::= expression CARET

unaryOperator ::= PLUS      // Arithmetic identity
                  | MINUS   // Arithmetic negation
                  | NOT     // Boolean not
                  | TILDE   // Bitwise not
                  | AND     // Address of
unary_expression ::= unaryOperator expression
or_return_expression ::= expression OR_RETURN


string_literal  ::= DQ_STRING_LITERAL
                    | SQ_STRING_LITERAL
numeric_literal ::= INTEGER_DEC_LITERAL
                    | INTEGER_HEX_LITERAL
                    | INTEGER_OCT_LITERAL
                    | INTEGER_BIN_LITERAL
                    | FLOAT_DEC_LITERAL
                    | COMPLEX_INTEGER_DEC_LITERAL
                    | COMPLEX_FLOAT_LITERAL

boolean_literal ::= TRUE
                    | FALSE

literal_expression ::= string_literal
         | numeric_literal
         | boolean_literal
         | matrixLiteral_expression
         | arrayLiteral_expression

arrayLiteral_expression ::= LBRACKET (INTEGER_DEC_LITERAL|QUESTION) RBRACKET LBRACE expression (COMMA expression)* RBRACE
matrixLiteral_expression ::= MATRIX LBRACKET INTEGER_DEC_LITERAL COMMA INTEGER_DEC_LITERAL RBRACKET LBRACE expression (COMMA expression)* RBRACE

arrayIndex_expression ::= expression LBRACKET expression RBRACKET
arraySlice_expression ::= expression LBRACKET expression? COLON expression? RBRACKET

matrixIndex_expression ::= expression LBRACKET expression COMMA expression RBRACKET

tag ::= HASH IDENTIFIER ( literal_expression | (LPAREN expressionsList? RPAREN))?

forStatement ::= label? tag? forHead forBody
private label ::= IDENTIFIER COLON


forHead ::= forIn|forTraditional
forBody ::= block | forSingleStatement
forSingleStatement ::= DO statementAllowedInBlock

breakStatement ::= BREAK label?
continueStatement ::= CONTINUE label?

// Statements that are allowed in "blocks" like for loops, if statements, etc.
// A block is a sequence of statements contained in braces.
block ::= LBRACE (statementAllowedInBlock)* RBRACE
statementAllowedInBlock ::= statement|assignmentStatement|expression

forTraditional ::= FOR (forStartStatement? SEMICOLON)? expression? (SEMICOLON forEndStatement?)?
forIn ::= FOR IDENTIFIER (COMMA IDENTIFIER)* IN expression

private forStartStatement ::=   variableInitialization | assignmentStatement | call_expression
private forEndStatement ::=   assignmentStatement | call_expression

ifStatement ::= IF  ifHead block (elseIfBlock)* (elseBlock)?
ifHead ::=  (variableInitialization (COMMA variableInitialization)* SEMICOLON)? expression
elseIfBlock ::= ELSE IF ifHead block
elseBlock ::= ELSE block

whenStatement ::= WHEN expression block (elseWhenBlock)* (elseBlock)?
elseWhenBlock ::= ELSE WHEN expression block

switchStatement ::= tag? SWITCH IN? ifHead? LBRACE (switchCaseBlock)* RBRACE
switchCaseBlock ::= CASE (caseExpression(COMMA caseExpression)*)? COLON (statementAllowedInBlock|FALLTHROUGH)*

caseExpression ::= expression
                  | typeDefinition_expression
                  | DOT IDENTIFIER

deferStatement ::= DEFER expression
                | ifStatement
                | forStatement
                | switchStatement
                | assignmentStatement
                | block
