{
  parserImports="static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  parserClass="com.lasagnerd.odin.lang.OdinParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Odin"
  psiImplClassSuffix="Impl"
  psiPackage="com.lasagnerd.odin.lang.psi"
  psiImplPackage="com.lasagnerd.odin.lang.psi.impl"

  elementTypeHolderClass="com.lasagnerd.odin.lang.psi.OdinTypes"
  elementTypeClass="com.lasagnerd.odin.lang.psi.OdinElementType"
  tokenTypeClass="com.lasagnerd.odin.lang.psi.OdinTokenType"
  parserUtilClass="com.lasagnerd.odin.lang.OdinParserUtil"

  tokens=[
        LINE_COMMENT='regexp://[^\r\n]*'
        BLOCK_COMMENT='regexp:/\*[\s\S]*?\*/'

        PACKAGE='regexp:package'
        IMPORT='regexp:import'
        PROC='regexp:proc'
        RETURN='regexp:return'
        DEFER='regexp:defer'
        STRUCT='regexp:struct'
        FOR='regexp:for'
        IN='regexp:in'
        NOT_IN='regexp:not_in'
        DO='regexp:do'
        IF_TOKEN='regexp:if'
        ELSE_TOKEN='regexp:else'
        SWITCH='regexp:switch'
        CASE='regexp:case'
        FALLTHROUGH='regexp:fallthrough'
        TRUE='regexp:true'
        FALSE='regexp:false'
        WHEN='regexp:when'
        BREAK='regexp:break'
        CONTINUE='regexp:continue'
        NIL='regexp:nil'
        TRIPLE_DASH='regexp:---'
        OR_ELSE='regexp:or_else'
        OR_RETURN='regexp:or_return'
        OR_BREAK='regexp:or_break'
        OR_CONTINUE='regexp:or_continue'
        FOREIGN='regexp:foreign'
        CAST='regexp:cast'
        AUTO_CAST='regexp:AUTO_CAST'
        TRANSMUTE='regexp:TRANSMUTE'
        DYNAMIC='regexp:dynamic'
        BIT_SET='regexp:bit_set'
        MAP='regexp:map'
        USING='regexp:using'
        ENUM='regexp:enum'
        UNION='regexp:union'
        DISTINCT='regexp:distinct'
        WHERE='regexp:where'

        IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DQ_STRING_LITERAL='regexp:"[^"]*"'
        SQ_STRING_LITERAL="regexp:'[^']+?'"
        RAW_STRING_LITERAL='regexp:`[^`]*`'
        INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*'
        INTEGER_HEX_LITERAL='regexp:0x[0-9a-fA-F][0-9a-fA-F_]*'
        INTEGER_OCT_LITERAL='regexp:0o[0-7][0-7_]*'
        INTEGER_BIN_LITERAL='regexp:0b[01][01_]*'
        FLOAT_DEC_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*'
        COMPLEX_FLOAT_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*[ijk]'
        COMPLEX_INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*[ijk]'

        EQ='regexp:='
        COLON='regexp::'

        LBRACE='regexp:\{'
        RBRACE='regexp:}'
        LPAREN='regexp:\('
        RPAREN='regexp:\)'

        LBRACKET='regexp:\['
        RBRACKET='regexp:]'
        HASH='regexp:#'

        DOT='regexp:\.'
        ARROW='regexp:->'
        COMMA='regexp:,'
        SEMICOLON='regexp:;'
        QUESTION='regexp:\?'
        CARET='regexp:\^'
        AT='regexp:@'
        DOLLAR='regexp:\$'
        DOT_QUESTION='regexp:\.\?'

        // Operators
        EQEQ='regexp:=='
        NEQ='regexp:!='
        LT='regexp:<'
        GT='regexp:>'
        LTE='regexp:<='
        GTE='regexp:>='

        // Boolean operators
        ANDAND='regexp:&&'
        OROR='regexp:\|\|'
        NOT='regexp:!'
        ANDNOT='regexp:&~'


        // Arithmetic operators
        PLUS='regexp:\+'
        MINUS='regexp:-'
        STAR='regexp:\*'
        DIV='regexp:/'
        MOD='regexp:%'
        REMAINDER='regexp:%%'

        // Bitwise operators
        AND='regexp:&'
        PIPE='regexp:\|'
        TILDE='regexp:~'
        LSHIFT='regexp:<<'
        RSHIFT='regexp:>>'


        // Assignment operators
        PLUS_EQ='regexp:\+='
        MINUS_EQ='regexp:-='
        STAR_EQ='regexp:\*='
        DIV_EQ='regexp:/='
        MOD_EQ='regexp:%='
        REMAINDER_EQ='regexp:%%='
        AND_EQ='regexp:&='
        OR_EQ='regexp:\|='
        XOR_EQ='regexp:~='
        ANDAND_EQ='regexp:&&='
        OROR_EQ='regexp:\|\|='
        LSHIFT_EQ='regexp:<<='
        RSHIFT_EQ='regexp:>>='
        BITWISE_AND_NOT_EQ='regexp:&~='

        // Range Operators
        RANGE = 'regexp:\.\.'
        RANGE_INCLUSIVE='regexp:\.\.='
        RANGE_EXCLUSIVE='regexp:\.\.<'

        WHITE_SPACE='regexp:[ \t\f]+'
        NEW_LINE='regexp:(\r|\n|\r\n)+'
        EOS_TOKEN='EOS_TOKEN'

        MULTILINE_BLOCK_COMMENT='MULTILINE_BLOCK_COMMENT'

        BLOCK_COMMENT_CONTENT='BLOCK_COMMENT_CONTENT'
        BLOCK_COMMENT_START='BLOCK_COMMENT_START'
        BLOCK_COMMENT_END='BLOCK_COMMENT_END'

        DQ_STRING_START='DQ_STRING_START'
        DQ_STRING_END='DQ_STRING_END'

        SQ_STRING_START='SQ_STRING_START'
        SQ_STRING_END='SQ_STRING_END'
  ]

  extends('.*_expression') = expression
  extends('.*[sS]tatement') = statement
  extends('.*_primary') = primary
}


odinFile ::= packageClause eos (importDeclarationStatement eos)* (fileScopeStatement eos)* <<eof>>
packageClause ::= PACKAGE IDENTIFIER
importDeclarationStatement ::= IMPORT IDENTIFIER? DQ_STRING_LITERAL
doubleColonOperator ::= COLON COLON

fileScopeStatement ::= foreignImportDeclarationStatement
                | importDeclarationStatement
                | enumDeclarationStatement
                | unionDeclarationStatement
                | structDeclarationStatement
                | procedureDeclarationStatement
                | constantInitializationStatement
                | bitsetDeclarationStatement
                | variableInitializationStatement
                | variableDeclarationStatement
                | procedureOverloadStatement
                | foreignStatement
                | whenStatement
                | tagStatement_expression

foreignImportDeclarationStatement ::= (attributeStatement eos*)* FOREIGN IMPORT ( IDENTIFIER? DQ_STRING_LITERAL | IDENTIFIER? blockStart DQ_STRING_LITERAL (COMMA DQ_STRING_LITERAL)* COMMA? blockEnd)
foreignStatement ::= (attributeStatement eos)* FOREIGN IDENTIFIER? foreignBlock

foreignBlock ::= blockStart foreignStatementList? blockEnd

foreignStatementList ::= (sos? foreignBlockStatement eos)+
foreignBlockStatement ::= variableDeclarationStatement
                         |foreignProcedureDeclarationStatement
                         |whenStatement
foreignProcedureDeclarationStatement ::= (attributeStatement eos*)* IDENTIFIER doubleColonOperator PROC string_literal? LPAREN parameterList* RPAREN [ARROW returnType] TRIPLE_DASH

// Attributes
attributeStatement ::=  AT IDENTIFIER
                       | AT arguments
// Struct
structDeclarationStatement ::= (attributeStatement eos*)* IDENTIFIER doubleColonOperator DISTINCT? structSpec
structSpec ::= STRUCT [LPAREN parameterList RPAREN [eos* whereClause eos*]] <<enterMode "BLOCK">>[tagStatement_expression] <<exitMode "BLOCK">> structBlock
structBlock ::= blockStart [structBody] blockEnd
structBody ::= fieldDeclarationStatement (COMMA fieldDeclarationStatement)*  [COMMA|EOS_TOKEN]
fieldDeclarationStatement ::= USING? tagHead? IDENTIFIER (COMMA IDENTIFIER)* COLON typeDefinition_expression [RAW_STRING_LITERAL]

// Enum
enumDeclarationStatement ::= (attributeStatement eos*)* USING? IDENTIFIER doubleColonOperator DISTINCT? enumSpec
enumSpec ::= ENUM [IDENTIFIER (DOT IDENTIFIER)*] enumBlock
enumBlock ::= blockStart [enumBody] blockEnd
enumBody ::= enumAssignment (COMMA enumAssignment)* [EOS_TOKEN|COMMA]
private enumAssignment ::= IDENTIFIER [EQ expression]
// Union
unionDeclarationStatement ::= (attributeStatement eos*)* IDENTIFIER doubleColonOperator DISTINCT? unionSpec
unionSpec ::= UNION [LPAREN parameterList RPAREN [eos* whereClause eos*]] <<enterMode "BLOCK">>[tagStatement_expression] <<exitMode "BLOCK">> unionBlock
unionBlock ::= blockStart [unionBody] blockEnd
unionBody ::= typeDefinition_expression (COMMA typeDefinition_expression)* [COMMA|EOS_TOKEN]

// Bit Set
bitsetDeclarationStatement ::= IDENTIFIER doubleColonOperator DISTINCT? bitSetType

// Procedure
procedureDeclarationStatement ::= (attributeStatement eos*)* IDENTIFIER doubleColonOperator procedureType procedureBody
procedure_expression ::= procedureType procedureBody
procedureType    ::= tagStatement_expression? PROC string_literal? LPAREN parameterList* RPAREN [ARROW returnType] <<enterMode "BLOCK">> [eos* whereClause eos*] <<exitMode "BLOCK">>

whereClause ::= WHERE expression (COMMA expression)*
procedureBody ::= block|TRIPLE_DASH

returnType          ::= NOT | LPAREN parameterList RPAREN | typeDefinition_expression

returnStatement ::= [tagStatement_expression] RETURN returnArgumentList?
private returnArgumentList ::= expression (COMMA expression)* COMMA?

usingStatement ::= USING expression

// Procedure overloading
procedureOverloadStatement ::= (attributeStatement eos*)* IDENTIFIER doubleColonOperator PROC LBRACE IDENTIFIER (COMMA IDENTIFIER)* COMMA? RBRACE

// Variables and constants
typeDefinition_expression   ::= DISTINCT? [tagStatement_expression] type [DIV typeDefinition_expression]
type ::= mapType
         | matrixType
         | bitSetType
         | multiPointerType
         | arrayType
         | procedureType
         | structSpec
         | enumSpec
         | unionSpec
         | pointerType
         | typeWithParameters



typeWithParameters ::= typeIdentifier [LPAREN type (COMMA type)* RPAREN]
typeIdentifier ::= DOLLAR IDENTIFIER
                   | IDENTIFIER (DOT IDENTIFIER)*

pointerType ::= CARET type
multiPointerType ::= LBRACKET CARET RBRACKET type


bitSetType       ::= BIT_SET LBRACKET expression [SEMICOLON typeDefinition_expression] RBRACKET
mapType          ::= MAP LBRACKET typeDefinition_expression RBRACKET typeDefinition_expression
matrixType       ::= MATRIX LBRACKET expression COMMA expression RBRACKET typeDefinition_expression
arrayType        ::= [tagHead] LBRACKET [QUESTION|DYNAMIC|expression] RBRACKET typeDefinition_expression

constantInitializationStatement ::= symbolDefinitionHead colonClosing expression
colonClosing ::= COLON

private symbolDefinitionHead ::= (attributeStatement eos*)* [tagHead] identifierList colonOpening typeDefinition_expression?
colonOpening ::= COLON

variableInitializationStatement ::= symbolDefinitionHead EQ expressionsList

identifierList ::= IDENTIFIER (COMMA IDENTIFIER)*

assignmentStatement ::= [tagHead] leftHandExpressions assignmentOperator expressionsList

leftHandExpressions ::= leftHandExpression (COMMA leftHandExpression)*
leftHandExpression ::= primary_expression


expressionsList ::= expression (COMMA expression)*

assignmentOperator ::= EQ
                       | PLUS_EQ
                       | MINUS_EQ
                       | STAR_EQ
                       | DIV_EQ
                       | MOD_EQ
                       | REMAINDER_EQ
                       | AND_EQ
                       | OR_EQ
                       | XOR_EQ
                       | ANDAND_EQ
                       | OROR_EQ
                       | LSHIFT_EQ
                       | RSHIFT_EQ
                       | BITWISE_AND_NOT_EQ

variableDeclarationStatement ::= (attributeStatement eos?)* IDENTIFIER (COMMA IDENTIFIER)* COLON typeDefinition_expression

// Parameters for procedures and assignments
parameterList ::= parameter (COMMA parameter)* COMMA?
parameter ::= tagStatement_expression? (
              variadicParameter
              | parameterInitialization
              | parameterDeclarationStatement
              | parameterType
              )
private parameterType ::= RANGE? typeDefinition_expression

parameterDeclarationStatement ::= [USING|DOLLAR] tagStatement_expression? IDENTIFIER (COMMA DOLLAR? IDENTIFIER)* COLON parameterType parameterTypeSpecialization?
parameterTypeSpecialization ::= DIV expression
private parameterInitialization ::= IDENTIFIER COLON typeDefinition_expression? EQ expression
private variadicParameter ::= IDENTIFIER COLON RANGE expression


// Function calls
argumentList  ::= argument (COMMA argument)* COMMA?
namedArgument ::= IDENTIFIER EQ expression { extends = argument}
argument      ::= namedArgument
                  | unnamedArgument
unnamedArgument ::= expression { extends = argument}

call_expression ::= caller LPAREN argumentList? RPAREN

caller ::=  parenthesized_expression | identifier_expression


binary_expression ::= expression binaryOperator expression
binaryOperator ::= PLUS
                   | MINUS
                   | STAR
                   | DIV
                   | MOD
                   | REMAINDER
                   | PIPE
                   | TILDE
                   | ANDAND
                   | ANDNOT
                   | AND
                   | OROR
                   | LSHIFT
                   | RSHIFT
                   | EQEQ
                   | NEQ
                   | LT
                   | GT
                   | LTE
                   | GTE
                   | RANGE_INCLUSIVE
                   | RANGE_EXCLUSIVE
                   | OR_ELSE
                   | IN
                   | NOT_IN

parenthesized_expression ::= LPAREN <<enterMode "PAR">> expression <<exitMode "PAR">> RPAREN

// Does it make sense to have literal expressions in the chain?

// All expressions
expression ::= implicitSelector_expression
               | primary_expression
               | identifier_expression
               | ternary_expression
               | procedure_expression
               | maybe_expression
               | unary_expression
               | binary_expression
               | or_return_expression
               | or_break_expression
               | or_continue_expression
               | set_expression
               | uninitialized_expression
               | cast_expression
               | transmute_expression
               | auto_cast_expression
               | typeDefinitionValue_expression
               | typeDefinition_expression
               | tagStatement_expression

typeDefinitionValue_expression ::= type compoundLiteralValue
primary_expression ::= [tagHead] primary
primary ::= operand_primary | caret_primary | combined_primary
combined_primary ::= primary ( DOT IDENTIFIER
                              | ARROW IDENTIFIER
                              | index
                              | typeAssertion
                              | slice
                              | arguments
                              )
caret_primary ::= primary CARET
operand_primary ::=  literal | identifier_expression | parenthesized_expression

private index ::= LBRACKET expression [COMMA expression] RBRACKET
private slice ::= LBRACKET expression? COLON expression? RBRACKET
private arguments ::= LPAREN argumentList? RPAREN
private typeAssertion ::= DOT LPAREN typeDefinition_expression RPAREN

private ternary_expression ::= ternary_cond_expression
                               | ternary_if_expression
                               | ternary_when_expression
ternary_cond_expression ::= expression QUESTION expression COLON expression
ternary_if_expression ::= expression if expression else expression
ternary_when_expression ::= expression WHEN expression else expression

cast_expression ::= CAST LPAREN typeDefinition_expression RPAREN expression
transmute_expression ::= TRANSMUTE LPAREN expression RPAREN expression
auto_cast_expression ::= AUTO_CAST expression
nil_literal ::= NIL
uninitialized_expression ::= TRIPLE_DASH
identifier_expression ::= IDENTIFIER

set_expression ::= LBRACE [expression (COMMA expression)* COMMA?] RBRACE

implicitSelector_expression ::= DOT expression
maybe_expression ::= expression DOT_QUESTION

unaryOperator ::= PLUS      // Arithmetic identity
                  | MINUS   // Arithmetic negation
                  | NOT     // Boolean not
                  | TILDE   // Bitwise not
                  | AND     // Address of
                  | RANGE
unary_expression ::= unaryOperator primary_expression
or_return_expression ::= expression OR_RETURN
or_break_expression ::= expression OR_BREAK [IDENTIFIER]
or_continue_expression ::= expression OR_CONTINUE [IDENTIFIER]


string_literal  ::= DQ_STRING_LITERAL
                    | SQ_STRING_LITERAL
                    | RAW_STRING_LITERAL
numeric_literal ::= INTEGER_DEC_LITERAL
                    | INTEGER_HEX_LITERAL
                    | INTEGER_OCT_LITERAL
                    | INTEGER_BIN_LITERAL
                    | FLOAT_DEC_LITERAL
                    | COMPLEX_INTEGER_DEC_LITERAL
                    | COMPLEX_FLOAT_LITERAL

boolean_literal ::= TRUE
                    | FALSE


basic_literal ::= nil_literal
                  | string_literal
                  | numeric_literal
                  | boolean_literal
                  | tripleDashLiteral_expression

referenced_identifier ::= IDENTIFIER (DOT IDENTIFIER)*
compound_types ::= arrayType | matrixType | bitSetType  | mapType | referenced_identifier
compound_literal ::= compound_types compoundLiteralValue

literal ::= basic_literal | compound_literal
compoundLiteralValue ::= (<<isModeOn "PAR">> | <<isModeOff "BLOCK">>) compoundValueStart [compoundLiteralValueBody] compoundValueEnd
compoundValueStart  ::= LBRACE
compoundValueEnd  ::= RBRACE
compoundLiteralValueBody ::= [expression EQ] expression (COMMA [expression EQ] expression)* [EOS_TOKEN|COMMA]

tripleDashLiteral_expression ::= TRIPLE_DASH

tagStatement_expression ::= tagHead [literal | (LPAREN expressionsList? RPAREN)]
tagHead ::= HASH IDENTIFIER

forStatement ::= label? tagStatement_expression? forHead statementBody
label ::= IDENTIFIER COLON

forHead ::= FOR <<enterMode "BLOCK">> (forIn|forTraditional) <<exitMode "BLOCK">>
doStatement ::= DO statement

breakStatement ::= BREAK IDENTIFIER?
continueStatement ::= CONTINUE IDENTIFIER?

// Statements that are allowed in "blocks" like for loops, if statements, etc.
// A block is a sequence of statements contained in braces.
block ::= eos* tagStatement_expression* blockStart statementList? blockEnd
blockStart ::= LBRACE
blockEnd ::= RBRACE

// In the current implementation, when entering a parenthesis, bracket or brace block, the parser will expect to find
// a statement or an end of statement. The problem is that empty blocks are allowed, but will lead to a parsing error.

// TODO introduce new lexer state that ignores EOS_TOKEN tokens

eos ::= SEMICOLON | <<eof>> | EOS_TOKEN | <<multilineBlockComment>> | <<atClosingBrace>> | <<afterClosingBrace>>
sos ::= SEMICOLON | NEW_LINE | EOS_TOKEN | <<afterClosingBrace>> | <<multilineBlockComment>>
statementList ::= (sos? statement eos)+
statement ::= assignmentStatement
                | procedureDeclarationStatement
                | variableInitializationStatement
                | structDeclarationStatement
                | enumDeclarationStatement
                | unionDeclarationStatement
                | procedureOverloadStatement
                | constantInitializationStatement
                | variableDeclarationStatement
                | bitsetDeclarationStatement
                | blockStatement
                | forStatement
                | ifStatement
                | whenStatement
                | switchStatement
                | deferStatement
                | returnStatement
                | breakStatement
                | continueStatement
                | attributeStatement
                | usingStatement
                | expressionStatement
                | fallthroughStatement
                | foreignStatement
                | foreignImportDeclarationStatement


fallthroughStatement ::= FALLTHROUGH
expressionStatement ::= expression
blockStatement ::= [(tagStatement_expression eos*)|label] block

private forTraditional ::= (forStartStatement? SEMICOLON)? expression? (SEMICOLON forEndStatement?)?
private forIn ::= forExpression (COMMA forExpression)* IN expression
private forExpression ::= AND? primary_expression
private forStartStatement ::=   variableInitializationStatement | assignmentStatement | call_expression
private forEndStatement ::=   assignmentStatement | call_expression

ifStatement ::= [label] [tagHead] if condition statementBody (sos elseIfBlock)* [sos elseBlock]
private statementBody ::= block|doStatement
condition ::= <<enterMode "BLOCK">> [ifInit SEMICOLON] expression <<exitMode "BLOCK">>
private switchCondition ::= [ifInit SEMICOLON] expression?
private ifInit ::= assignmentStatement|variableInitializationStatement|variableDeclarationStatement
elseIfBlock ::= elseIf condition statementBody
elseIf ::= else if
elseBlock ::= else statementBody
if ::= IF_TOKEN
else ::= ELSE_TOKEN
whenStatement ::= WHEN condition statementBody (sos elseWhenBlock)* (sos elseBlock)?
elseWhenBlock ::= else WHEN condition statementBody

switchStatement ::= [label] [tagStatement_expression] switchHead switchBody
switchHead ::= SWITCH IN? <<enterMode "BLOCK">> switchCondition? <<exitMode "BLOCK">>
switchBody ::= eos* blockStart switchCases blockEnd
switchCases ::= switchCase*
switchCase ::= CASE (caseExpression(COMMA caseExpression)*)? caseBlock
caseBlock ::= COLON statementList?

caseExpression ::= expression
                  | typeDefinition_expression
                  | DOT IDENTIFIER

deferStatement ::= DEFER deferrableStatement
private deferrableStatement ::= assignmentStatement
                                | expression
                                | ifStatement
                                | forStatement
                                | switchStatement
                                | block
