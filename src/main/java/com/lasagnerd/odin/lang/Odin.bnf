{
  parserImports="static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  parserClass="com.lasagnerd.odin.lang.OdinParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"


  psiClassPrefix="Odin"
  psiImplClassSuffix="Impl"

  psiPackage="com.lasagnerd.odin.lang.psi"
  psiImplPackage="com.lasagnerd.odin.lang.psi.impl"

  elementTypeHolderClass="com.lasagnerd.odin.lang.psi.OdinTypes"
  elementTypeClass="com.lasagnerd.odin.lang.psi.OdinElementType"
  tokenTypeClass="com.lasagnerd.odin.lang.psi.OdinTokenType"
  parserUtilClass="com.lasagnerd.odin.lang.OdinParserUtil"

  tokens=[
        LINE_COMMENT='regexp://[^\r\n]*'
        BLOCK_COMMENT='regexp:/\*[\s\S]*?\*/'

        PACKAGE='regexp:package'
        IMPORT='regexp:import'
        PROC='regexp:proc'
        RETURN='regexp:return'
        DEFER='regexp:defer'
        STRUCT='regexp:struct'
        FOR='regexp:for'
        IN='regexp:in'
        NOT_IN='regexp:not_in'
        DO='regexp:do'
        IF_TOKEN='regexp:if'
        ELSE_TOKEN='regexp:else'
        SWITCH='regexp:switch'
        CASE='regexp:case'
        FALLTHROUGH='regexp:fallthrough'
        TRUE='regexp:true'
        FALSE='regexp:false'
        WHEN='regexp:when'
        BREAK='regexp:break'
        CONTINUE='regexp:continue'
        NIL='regexp:nil'
        TRIPLE_DASH='regexp:---'
        OR_ELSE='regexp:or_else'
        OR_RETURN='regexp:or_return'
        OR_BREAK='regexp:or_break'
        OR_CONTINUE='regexp:or_continue'
        FOREIGN='regexp:foreign'
        CAST='regexp:cast'
        AUTO_CAST='regexp:AUTO_CAST'
        TRANSMUTE='regexp:TRANSMUTE'
        DYNAMIC='regexp:dynamic'
        BIT_SET='regexp:bit_set'
        MAP='regexp:map'
        USING='regexp:using'
        ENUM='regexp:enum'
        UNION='regexp:union'
        DISTINCT='regexp:distinct'
        WHERE='regexp:where'

        IDENTIFIER_TOKEN='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DQ_STRING_LITERAL='regexp:"[^"]*"'
        SQ_STRING_LITERAL="regexp:'[^']+?'"
        RAW_STRING_LITERAL='regexp:`[^`]*`'
        INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*'
        INTEGER_HEX_LITERAL='regexp:0x[0-9a-fA-F][0-9a-fA-F_]*'
        INTEGER_OCT_LITERAL='regexp:0o[0-7][0-7_]*'
        INTEGER_BIN_LITERAL='regexp:0b[01][01_]*'
        FLOAT_DEC_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*'
        COMPLEX_FLOAT_LITERAL='regexp:[0-9][0-9_]*\.[0-9][0-9_]*[ijk]'
        COMPLEX_INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*[ijk]'

        EQ='regexp:='
        COLON='regexp::'

        LBRACE='regexp:\{'
        RBRACE='regexp:}'
        LPAREN='regexp:\('
        RPAREN='regexp:\)'

        LBRACKET='regexp:\['
        RBRACKET='regexp:]'
        HASH='regexp:#'

        DOT='regexp:\.'
        ARROW='regexp:->'
        COMMA='regexp:,'
        SEMICOLON='regexp:;'
        QUESTION='regexp:\?'
        CARET='regexp:\^'
        AT='regexp:@'
        DOLLAR='regexp:\$'
        DOT_QUESTION='regexp:\.\?'

        // Operators
        EQEQ='regexp:=='
        NEQ='regexp:!='
        LT='regexp:<'
        GT='regexp:>'
        LTE='regexp:<='
        GTE='regexp:>='

        // Boolean operators
        ANDAND='regexp:&&'
        OROR='regexp:\|\|'
        NOT='regexp:!'
        ANDNOT='regexp:&~'


        // Arithmetic operators
        PLUS='regexp:\+'
        MINUS='regexp:-'
        STAR='regexp:\*'
        DIV='regexp:/'
        MOD='regexp:%'
        REMAINDER='regexp:%%'

        // Bitwise operators
        AND='regexp:&'
        PIPE='regexp:\|'
        TILDE='regexp:~'
        LSHIFT='regexp:<<'
        RSHIFT='regexp:>>'


        // Assignment operators
        PLUS_EQ='regexp:\+='
        MINUS_EQ='regexp:-='
        STAR_EQ='regexp:\*='
        DIV_EQ='regexp:/='
        MOD_EQ='regexp:%='
        REMAINDER_EQ='regexp:%%='
        AND_EQ='regexp:&='
        OR_EQ='regexp:\|='
        XOR_EQ='regexp:~='
        ANDAND_EQ='regexp:&&='
        OROR_EQ='regexp:\|\|='
        LSHIFT_EQ='regexp:<<='
        RSHIFT_EQ='regexp:>>='
        BITWISE_AND_NOT_EQ='regexp:&~='

        // Range Operators
        RANGE = 'regexp:\.\.'
        RANGE_INCLUSIVE='regexp:\.\.='
        RANGE_EXCLUSIVE='regexp:\.\.<'

        WHITE_SPACE='regexp:[ \t\f]+'
        NEW_LINE='regexp:(\r|\n|\r\n)+'
        EOS_TOKEN='EOS_TOKEN'

        MULTILINE_BLOCK_COMMENT='MULTILINE_BLOCK_COMMENT'

        BLOCK_COMMENT_CONTENT='BLOCK_COMMENT_CONTENT'
        BLOCK_COMMENT_START='BLOCK_COMMENT_START'
        BLOCK_COMMENT_END='BLOCK_COMMENT_END'

        DQ_STRING_START='DQ_STRING_START'
        DQ_STRING_END='DQ_STRING_END'

        SQ_STRING_START='SQ_STRING_START'
        SQ_STRING_END='SQ_STRING_END'
  ]

  extends('.*Expression$') = expression
  extends('.*[sS]tatement$') = statement
  extends('.*Type$') = type

  methods('.*([iI]nitialization|[dD]eclaration).*') = [getDeclaredIdentifiers]
  implements('.*([iI]nitialization|[dD]eclaration).*') = 'com.lasagnerd.odin.lang.psi.OdinDeclaration'

  psiImplUtilClass="com.lasagnerd.odin.lang.psi.OdinPsiUtil"
}



odinFile                             ::= fileScope
fileScope                            ::= packageDeclaration eos importStatements fileScopeStatementList <<eof>> {
    methods=[getImportStatements]
}
private importStatements             ::= (importDeclarationStatement eos)*
private fileScopeStatementList       ::= (fileScopeStatement eos)*
packageDeclaration                   ::= PACKAGE declaredIdentifier
importDeclarationStatement           ::= IMPORT declaredIdentifier? DQ_STRING_LITERAL {methods=[alias="/declaredIdentifier" path="/DQ_STRING_LITERAL" getName setName getNameIdentifier getImportInfo] implements="com.intellij.psi.PsiNameIdentifierOwner"}
doubleColonOperator                  ::= COLON COLON

fileScopeStatement                   ::= foreignImportDeclarationStatement
                                         | importDeclarationStatement
                                         | enumDeclarationStatement
                                         | unionDeclarationStatement
                                         | structDeclarationStatement
                                         | procedureDeclarationStatement
                                         | constantInitializationStatement
                                         | bitsetDeclarationStatement
                                         | variableInitializationStatement
                                         | variableDeclarationStatement
                                         | procedureOverloadStatement
                                         | foreignStatement
                                         | whenStatement
                                         | directiveStatement

// @require foreign import entry "entryUnixNoCrtAmd64.asm"
foreignImportDeclarationStatement    ::= (attributeStatement EOS_TOKEN?)* FOREIGN IMPORT
        ( (declaredIdentifier? DQ_STRING_LITERAL) | (declaredIdentifier? blockStart DQ_STRING_LITERAL (COMMA DQ_STRING_LITERAL)* COMMA? blockEnd)) {methods=[alias="declaredIdentifier" paths="DQ_STRING_LITERAL"]}

foreignStatement                     ::= (attributeStatement EOS_TOKEN?)* FOREIGN IDENTIFIER_TOKEN? foreignBlock

foreignBlock                         ::= blockStart foreignStatementList? blockEnd

foreignStatementList                 ::= (sos? foreignBlockStatement eos)+
foreignBlockStatement                ::= variableDeclarationStatement
                                         |foreignProcedureDeclarationStatement
                                         |whenStatement
foreignProcedureDeclarationStatement ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator PROC stringLiteral? LPAREN [paramEntries] RPAREN [ARROW returnParameters] TRIPLE_DASH

// Attributes
attributeStatement                   ::= AT IDENTIFIER_TOKEN
                                         | AT arguments
// Struct
structDeclarationStatement           ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator DISTINCT? structType
structType                           ::= STRUCT [LPAREN polymorphicParameterList RPAREN [eos? whereClause eos?]] <<enterNoBlockMode>> directive* <<exitNoBlockMode>> structBlock
structBlock                          ::= blockStart [structBody] blockEnd
structBody                           ::= fieldDeclarationStatement (COMMA fieldDeclarationStatement)*  [COMMA|EOS_TOKEN]
fieldDeclarationStatement            ::= USING? tagHead? declaredIdentifier (COMMA declaredIdentifier)* COLON typeDefinitionExpression [RAW_STRING_LITERAL] { methods=[ getTypeDefinition ]  }

// Enum
enumDeclarationStatement             ::= (attributeStatement eos?)* USING? declaredIdentifier doubleColonOperator DISTINCT? enumType
enumType                             ::= ENUM [IDENTIFIER_TOKEN (DOT IDENTIFIER_TOKEN)*] enumBlock
enumBlock                            ::= blockStart [enumBody] blockEnd
enumBody                             ::= enumValueDeclaration (COMMA enumValueDeclaration)* [EOS_TOKEN|COMMA]
enumValueDeclaration                 ::= declaredIdentifier [EQ expression]
// Union
unionDeclarationStatement            ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator DISTINCT? unionType
unionType                            ::= UNION [LPAREN polymorphicParameterList RPAREN [eos? whereClause eos?]] <<enterNoBlockMode>> directive* <<exitNoBlockMode>> unionBlock
unionBlock                           ::= blockStart [unionBody] blockEnd
unionBody                            ::= typeDefinitionExpression (COMMA typeDefinitionExpression)* [COMMA|EOS_TOKEN]

// Bit Set
bitsetDeclarationStatement           ::= declaredIdentifier doubleColonOperator DISTINCT? bitSetType

// Procedure
procedureDeclarationStatement        ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator procedureType procedureBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getDeclarationsSpecs ] }
procedureType                        ::= directive? PROC stringLiteral? LPAREN [paramEntries] RPAREN [ARROW returnParameters] <<enterNoBlockMode>> [eos? whereClause eos?] <<exitNoBlockMode>>

whereClause                          ::= WHERE expression (COMMA expression)*
procedureBody                        ::= tripleDashBlock
                                          | block
private tripleDashBlock              ::= [directive] TRIPLE_DASH {pin=2}
returnParameters                     ::= NOT | LPAREN paramEntries RPAREN | typeDefinitionExpression

returnStatement                      ::= [directive] RETURN returnArgumentList?
private returnArgumentList           ::= expression (COMMA expression)* COMMA?

usingStatement                       ::= USING expression
directiveStatement                   ::= directive

// Procedure overloading
procedureOverloadStatement           ::= (attributeStatement eos?)* declaredIdentifier doubleColonOperator PROC LBRACE identifier (COMMA identifier)* COMMA? RBRACE

// TYPES

// Variables and constants
typeDefinitionExpression             ::= DISTINCT? [directive] type
type                                 ::= mapType
                                         | matrixType
                                         | bitSetType
                                         | multiPointerType
                                         | arrayType
                                         | procedureType
                                         | structType
                                         | enumType
                                         | unionType
                                         | pointerType
                                         | polymorphicType
                                         | constrainedType
                                         | parExpressionType
                                         | qualifiedType
                                         | callType
                                         | simpleRefType

callType                             ::= identifier arguments
constrainedType                      ::= type DIV type {pin=2}
polymorphicType                      ::= DOLLAR identifier
simpleRefType                        ::= identifier
qualifiedType                        ::= identifier DOT (callType | simpleRefType) {methods=[getPackageIdentifier getTypeIdentifier]}


pointerType                          ::= CARET type
multiPointerType                     ::= LBRACKET CARET RBRACKET type


bitSetType                           ::= BIT_SET LBRACKET expression [SEMICOLON typeDefinitionExpression] RBRACKET
mapType                              ::= MAP LBRACKET typeDefinitionExpression RBRACKET typeDefinitionExpression {methods=[getKeyType getValueType]}
matrixType                           ::= MATRIX LBRACKET expression COMMA expression RBRACKET typeDefinitionExpression
arrayType                            ::= [tagHead] LBRACKET [QUESTION|DYNAMIC|expression] RBRACKET typeDefinitionExpression {methods=[getTypeDefinition]}

constantInitializationStatement      ::= symbolDefinitionHead colonClosing expressionsList { methods=[getTypeDefinition]}
colonClosing                         ::= COLON

private symbolDefinitionHead         ::= (attributeStatement eos?)* [tagHead] [USING] identifierList colonOpening typeDefinitionExpression?
colonOpening                         ::= COLON

variableInitializationStatement      ::= symbolDefinitionHead EQ expressionsList { methods=[getTypeDefinition]}

identifierList                       ::= declaredIdentifier (COMMA declaredIdentifier)*
declaredIdentifier                   ::= [DOLLAR] IDENTIFIER_TOKEN { mixin = 'com.lasagnerd.odin.lang.psi.OdinIdentifierOwner' implements='com.intellij.psi.PsiNameIdentifierOwner' }

assignmentStatement                  ::= [tagHead] expressionsList assignmentOperator expressionsList
expressionsList                      ::= expression (COMMA expression)*

assignmentOperator                   ::= EQ
                                         | PLUS_EQ
                                         | MINUS_EQ
                                         | STAR_EQ
                                         | DIV_EQ
                                         | MOD_EQ
                                         | REMAINDER_EQ
                                         | AND_EQ
                                         | OR_EQ
                                         | XOR_EQ
                                         | ANDAND_EQ
                                         | OROR_EQ
                                         | LSHIFT_EQ
                                         | RSHIFT_EQ
                                         | BITWISE_AND_NOT_EQ

variableDeclarationStatement         ::= (attributeStatement eos?)* [USING] identifierList COLON typeDefinitionExpression { methods=[getTypeDefinition]}

// Parameters for procedures and assignments
private polymorphicParameterList     ::= polymorphicParameter (COMMA polymorphicParameter)* COMMA?
polymorphicParameter                 ::= directive? (
                                         variadicParameterDeclaration
                                         | parameterInitialization
                                         | parameterDecl
                                         )

paramEntries                         ::= paramEntry (COMMA paramEntry)* COMMA?
paramEntry                           ::= directive? (
                                         variadicParameterDeclaration
                                             | parameterInitialization
                                             | parameterDecl
                                             | unnamedParameter
                                         )
fake parameterDeclaration            ::= parameter+ typeDefinitionContainer? expression { methods=[getTypeDefinition]}
typeDefinitionContainer              ::= typeDefinitionExpression

parameter                            ::= [USING] directive? declaredIdentifier
parameterDecl                        ::= parameter (COMMA parameter)* COLON typeDefinitionContainer {extends=parameterDeclaration  methods=[getTypeDefinition]}
parameterInitialization              ::= parameter COLON [typeDefinitionContainer] EQ expression {extends=parameterDeclaration methods=[getTypeDefinition] }

variadicParameterDeclaration         ::= parameter COLON RANGE typeDefinitionContainer {extends=parameterDeclaration methods=[getTypeDefinition]}
unnamedParameter                     ::= RANGE? typeDefinitionContainer {extends=parameterDeclaration methods=[getTypeDefinition]}

// Function calls
private argumentList                 ::= argument (COMMA argument)* COMMA?
namedArgument                        ::= IDENTIFIER_TOKEN EQ expression { extends = argument}
argument                             ::= namedArgument
                                         | unnamedArgument
unnamedArgument                      ::= expression { extends = argument}


// Does it make sense to have literal expressions in the chain?

// All expressions
expression                           ::= postfixGroup
                                         | orElseExpression
                                         | ternaryGroup
                                         | rangeGroup
                                         | orGroup
                                         | andGroup
                                         | orderGroup
                                         | addGroup
                                         | mulGroup
                                         | unaryGroup
                                         | implicitSelectorExpression
                                         | maybeExpression
                                         | uninitializedExpression
                                         | callExpression
                                         | qualificationExpression
                                         | indexExpression
                                         | sliceExpression
                                         | dereferenceExpression
                                         | procedureExpression
                                         | transmuteExpression
                                         | autoCastExpression
                                         | castExpression
                                         | compoundLiteralExpression
                                         | primaryGroup



fake binaryExpression                ::= expression 'OP' expression {methods=[left="/expression[0]" getOperator right="/expression[1]"]}


mulExpression                        ::= expression STAR            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
divExpression                        ::= expression DIV             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
modExpression                        ::= expression MOD             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
remainderExpression                  ::= expression REMAINDER       <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
addExpression                        ::= expression PLUS            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
subExpression                        ::= expression MINUS           <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
bitwiseAndExpression                 ::= expression AND             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
bitwiseOrExpression                  ::= expression PIPE            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
bitwiseXorExpression                 ::= expression TILDE           <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
bitwiseAndNotExpression              ::= expression ANDNOT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
andExpression                        ::= expression ANDAND          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
orExpression                         ::= expression OROR            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
orElseExpression                     ::= expression OR_ELSE         <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression }
inExpression                         ::= expression IN              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
notInExpression                      ::= expression NOT_IN          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
ltExpression                         ::= expression LT              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
gtExpression                         ::= expression GT              <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
lteExpression                        ::= expression LTE             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
gteExpression                        ::= expression GTE             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
eqeqExpression                       ::= expression EQEQ            <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
neqExpression                        ::= expression NEQ             <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
lshiftExpression                     ::= expression LSHIFT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
rshiftExpression                     ::= expression RSHIFT          <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
rangeInclusiveExpression             ::= expression RANGE_INCLUSIVE <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}
rangeExclusiveExpression             ::= expression RANGE_EXCLUSIVE <<enterMode "OPERAND">>  expression <<exitMode "OPERAND" >>   { extends=binaryExpression elementType=binaryExpression}

private mulGroup                     ::= mulExpression
                                         | divExpression
                                         | modExpression
                                         | remainderExpression
                                         | bitwiseAndExpression
                                         | lshiftExpression
                                         | rshiftExpression
                                         | bitwiseAndNotExpression

private addGroup                     ::= addExpression
                                         | subExpression
                                         | bitwiseOrExpression
                                         | bitwiseXorExpression
                                         | inExpression
                                         | notInExpression

private orderGroup                   ::= ltExpression
                                         | gtExpression
                                         | lteExpression
                                         | gteExpression
                                         | eqeqExpression
                                         | neqExpression

private andGroup                     ::= andExpression

private orGroup                      ::= orExpression

private rangeGroup                   ::= rangeInclusiveExpression
                                         | rangeExclusiveExpression

private ternaryGroup                 ::= elvisExpression
                                         | ternaryIfExpression
                                         | ternaryWhenExpression

private postfixGroup                 ::= orReturnExpression
                                         | orBreakExpression
                                         | orContinueExpression
                                         | typeAssertionExpression


parenthesizedExpression              ::= LPAREN <<enterMode "PAR">> expression <<exitMode "PAR">> RPAREN

// should we define the arrow operator on its own?
fake refExpression                   ::= expression? (DOT|ARROW) identifier
simpleRefExpression                  ::= identifier {extends=refExpression elementType=refExpression}
qualificationExpression              ::= expression (DOT|ARROW) identifier {extends=refExpression elementType=refExpression}


implicitSelectorExpression           ::= DOT identifier
indexExpression                      ::= expression index
sliceExpression                      ::= expression slice
typeAssertionExpression              ::= expression DOT LPAREN type RPAREN {methods=[subject="/expression[0]" targetType="/expression[1]"]}
procedureExpression                  ::= procedureTypeContainer procedureBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getDeclarationsSpecs ] }
procedureTypeContainer               ::= procedureType
dereferenceExpression                ::= expression CARET
identifier                           ::= IDENTIFIER_TOKEN { methods = [getReference]}

callExpression                       ::= expression arguments

private primaryGroup                 ::= simpleRefExpression | parenthesizedExpression | typeDefinitionExpression | directiveExpression | literalExpression

literalExpression                    ::= basicLiteral

compoundLiteralExpression            ::= compoundLiteralTyped | compoundLiteralUntyped
fake compoundValue                   ::= {methods=[getCompoundValueBody]}
fake compoundLiteral                 ::= type? (compoundValueTyped | compoundValueUntyped)
compoundLiteralTyped                 ::= compoundType compoundValueTyped {extends=compoundLiteral}
compoundLiteralUntyped               ::= compoundValueUntyped {extends=compoundLiteral}

index                                ::= LBRACKET expression [COMMA expression] RBRACKET
slice                                ::= LBRACKET expression? COLON expression? RBRACKET
private arguments                    ::= LPAREN <<enterMode "PAR">> argumentList? <<exitMode "PAR">> RPAREN

elvisExpression                      ::= expression QUESTION <<enterMode "OPERAND">> expression COLON expression <<exitMode "OPERAND">>
ternaryIfExpression                  ::= expression if       <<enterMode "OPERAND">> expression else expression  <<exitMode "OPERAND">>
ternaryWhenExpression                ::= expression WHEN     <<enterMode "OPERAND">> expression else expression  <<exitMode "OPERAND">>

castExpression                       ::= CAST LPAREN typeDefinitionExpression RPAREN expression {methods=[typeDefinitionExpression="/expression[0]"]}
transmuteExpression                  ::= TRANSMUTE LPAREN expression RPAREN expression
autoCastExpression                   ::= AUTO_CAST expression
nilLiteral                           ::= NIL
uninitializedExpression              ::= TRIPLE_DASH

// TODO this is a duplicate of compoundLiteralValue but without the non-consuming <<>>-rules
// --> fix this
compoundValueUntyped                 ::= ((<<isModeOn "OPERAND">> | <<isModeOn "PAR">> | <<isModeOff "NO_BLOCK">>) compoundValueStart [compoundValueBody] compoundValueEnd)
                                         | (compoundValueStart [compoundValueBody] compoundValueEnd <<beforeOperator>>) {extends=compoundValue elementType=compoundValue}
maybeExpression                      ::= expression DOT_QUESTION

private unaryGroup                   ::= unaryPlusExpression
                                         | unaryMinusExpression
                                         | unaryTildeExpression
                                         | unaryAndExpression
                                         | unaryNotExpression
                                         | unaryRangeExpression



unaryPlusExpression                  ::= PLUS  <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryMinusExpression                 ::= MINUS <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryTildeExpression                 ::= TILDE <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryAndExpression                   ::= AND   <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryNotExpression                   ::= NOT   <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>
unaryRangeExpression                 ::= RANGE <<enterMode "OPERAND">> expression <<exitMode "OPERAND">>


orReturnExpression                   ::= expression OR_RETURN
orBreakExpression                    ::= expression OR_BREAK [IDENTIFIER_TOKEN]
orContinueExpression                 ::= expression OR_CONTINUE [IDENTIFIER_TOKEN]


stringLiteral                        ::= DQ_STRING_LITERAL
                                         | SQ_STRING_LITERAL
                                         | RAW_STRING_LITERAL

numericLiteral                       ::= INTEGER_DEC_LITERAL
                                         | INTEGER_HEX_LITERAL
                                         | INTEGER_OCT_LITERAL
                                         | INTEGER_BIN_LITERAL
                                         | FLOAT_DEC_LITERAL
                                         | COMPLEX_INTEGER_DEC_LITERAL
                                         | COMPLEX_FLOAT_LITERAL

booleanLiteral                       ::= TRUE
                                         | FALSE

basicLiteral                         ::= nilLiteral
                                         | stringLiteral
                                         | numericLiteral
                                         | booleanLiteral
//                                         | tripleDashLiteralExpression

private compoundType                 ::= arrayType | matrixType | bitSetType  | mapType | structType | qualifiedType | callType | simpleRefType | parExpressionType
parExpressionType                    ::= parenthesizedExpression


compoundValueTyped                   ::= ((<<isModeOn "PAR">> | <<isModeOff "NO_BLOCK">>) compoundValueStart [compoundValueBody] compoundValueEnd)
                                         | (compoundValueStart [compoundValueBody] compoundValueEnd <<beforeComma>>) {extends=compoundValue elementType=compoundValue}
compoundValueStart                   ::= LBRACE
compoundValueEnd                     ::= RBRACE
compoundValueBody                    ::= [expression EQ] expression (COMMA [expression EQ] expression)* [EOS_TOKEN|COMMA]

directiveExpression                  ::= directive
directive                            ::= tagHead [basicLiteral | (LPAREN expressionsList? RPAREN)]
tagHead                              ::= HASH IDENTIFIER_TOKEN



breakStatement                       ::= BREAK IDENTIFIER_TOKEN?
continueStatement                    ::= CONTINUE IDENTIFIER_TOKEN?

// Statements that are allowed in "blocks" like for loops, if statements, etc.
// A block is a sequence of statements contained in braces.
block                                ::= [eos] directive* [eos] blockStart statementList? blockEnd {methods=[getStatements]}
blockStart                           ::= LBRACE
blockEnd                             ::= RBRACE

// In the current implementation, when entering a parenthesis, bracket or brace block, the parser will expect to find
// a statement or an end of statement. The problem is that empty blocks are allowed, but will lead to a parsing error.

eos                                  ::= SEMICOLON | <<eof>> | EOS_TOKEN | <<multilineBlockComment>> | <<atClosingBrace>> | <<afterClosingBrace>>
sos                                  ::= SEMICOLON | NEW_LINE | EOS_TOKEN | <<afterClosingBrace>> | <<multilineBlockComment>>
statementList                        ::= (sos? statement eos)+
statement                            ::= assignmentStatement
                                         | procedureDeclarationStatement
                                         | variableInitializationStatement
                                         | structDeclarationStatement
                                         | enumDeclarationStatement
                                         | unionDeclarationStatement
                                         | procedureOverloadStatement
                                         | constantInitializationStatement
                                         | variableDeclarationStatement
                                         | bitsetDeclarationStatement
                                         | blockStatement
                                         | forInStatement
                                         | forStatement
                                         | conditionalStatement
                                         | whenStatement
                                         | switchStatement
                                         | deferStatement
                                         | returnStatement
                                         | breakStatement
                                         | continueStatement
                                         | usingStatement
                                         | expressionStatement
                                         | fallthroughStatement
                                         | foreignImportDeclarationStatement
                                         | foreignStatement
                                         | importDeclarationStatement


fallthroughStatement                 ::= FALLTHROUGH
expressionStatement                  ::= orReturnExpression
                                         | orBreakExpression
                                         | orContinueExpression
                                         | callExpression
                                         | qualificationExpression
                                         | primaryGroup

label                                ::= IDENTIFIER_TOKEN COLON
blockStatement                       ::= [(directive eos?)|label] block {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getDeclarationsSpecs ] }

deferStatement                       ::= DEFER deferrableStatement
private deferrableStatement          ::= assignmentStatement
                                         | expression
                                         | conditionalStatement
                                         | forStatement
                                         | switchStatement
                                         | block

// Control Flows

// Shared rules among all control flow statements
controlFlowInit                      ::= assignmentStatement
                                         | variableInitializationStatement
                                         | variableDeclarationStatement
                                         | callExpression

condition                            ::= expression
doStatement                          ::= DO statement
statementBody                        ::= block|doStatement

// For
forStatement                         ::= label? directive? forBlock
private forHead                      ::= <<enterNoBlockMode>> [[[controlFlowInit] SEMICOLON] condition? [SEMICOLON [forUpdate]]] <<exitNoBlockMode>>
forBlock                             ::= FOR forHead statementBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getDeclarationsSpecs ] }
forUpdate                            ::= assignmentStatement | callExpression

// For-In
forInStatement                       ::= label? directive? forInBlock
forInBlock                           ::= FOR <<enterNoBlockMode>> [forInParameter (COMMA forInParameter)*] IN expression <<exitNoBlockMode>> statementBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getDeclarationsSpecs ] }
forInParameter                       ::= AND? declaredIdentifier

// Conditional statement (=if-elseif-else)
private conditionalHead              ::= <<enterNoBlockMode>> [[controlFlowInit] SEMICOLON] condition <<exitNoBlockMode>>

conditionalStatement                 ::= [label] [tagHead] ifBlock (sos elseIfBlock)* [sos elseBlock]

ifBlock                              ::= if conditionalHead statementBody {
                                                implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock"
                                                methods = [ getBlockStatements getDeclarationsSpecs ]
                                            }
elseIfBlock                          ::= elseIf conditionalHead statementBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getDeclarationsSpecs ] }
elseIf                               ::= else if
elseBlock                            ::= else statementBody {implements="com.lasagnerd.odin.lang.psi.OdinScopeBlock" methods = [ getBlockStatements getDeclarationsSpecs ] }
if                                   ::= IF_TOKEN
else                                 ::= ELSE_TOKEN

// Switch
switchStatement                      ::= [label] [directive] SWITCH IN? switchHead switchBody
private switchHead                   ::= <<enterNoBlockMode>> [[controlFlowInit SEMICOLON] [expression]] <<exitNoBlockMode>>
switchBody                           ::= eos? blockStart switchCases blockEnd
switchCases                          ::= switchCase*
switchCase                           ::= CASE [expression (COMMA expression)*] caseBlock
caseBlock                            ::= COLON statementList?

// When statement (compile time, which means it does not support an init block)
whenStatement                        ::= [label] [tagHead] WHEN <<enterNoBlockMode>> condition <<exitNoBlockMode>> statementBody (sos elseWhenBlock)* [sos elseBlock]
elseWhenBlock                        ::= else WHEN <<enterNoBlockMode>>  condition <<exitNoBlockMode>> statementBody



