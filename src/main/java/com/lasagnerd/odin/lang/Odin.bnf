{
  parserClass="com.lasagnerd.odin.lang.OdinParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Odin"
  psiImplClassSuffix="Impl"
  psiPackage="com.lasagnerd.odin.lang.psi"
  psiImplPackage="com.lasagnerd.odin.lang.psi.impl"

  elementTypeHolderClass="com.lasagnerd.odin.lang.psi.OdinTypes"
  elementTypeClass="com.lasagnerd.odin.lang.psi.OdinElementType"
  tokenTypeClass="com.lasagnerd.odin.lang.psi.OdinTokenType"

  tokens=[
        LINE_COMMENT='regexp://[^\r\n]*'
        BLOCK_COMMENT='regexp:/\*[\s\S]*?\*/'

        PACKAGE='regexp:package'
        IMPORT='regexp:import'
        PROC='regexp:proc'
        RETURN='regexp:return'
        DEFER='regexp:defer'
        STRUCT='regexp:struct'
        FOR='regexp:for'
        IN='regexp:in'
        DO='regexp:do'
        IF='regexp:if'
        ELSE='regexp:else'
        SWITCH='regexp:switch'
        CASE='regexp:case'
        FALLTHROUGH='regexp:fallthrough'
        TRUE='regexp:true'
        FALSE='regexp:false'

        IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        DQ_STRING_LITERAL='regexp:"[^"]*"'
        INTEGER_DEC_LITERAL='regexp:[0-9][0-9_]*'
        INTEGER_HEX_LITERAL='regexp:0x[0-9a-fA-F][0-9a-fA-F_]*'
        INTEGER_OCT_LITERAL='regexp:0o[0-7][0-7_]*'

        EQ='regexp:='
        COLON='regexp::'

        LBRACE='regexp:\{'
        RBRACE='regexp:}'
        LPAREN='regexp:\('
        RPAREN='regexp:\)'

        LBRACKET='regexp:\['
        RBRACKET='regexp:]'
        HASH='regexp:#'

        DOT='regexp:\.'
        ARROW='regexp:->'
        COMMA='regexp:,'
        SEMICOLON='regexp:;'
        QUESTION='regexp:\?'

        // Operators
        EQEQ='regexp:=='
        NEQ='regexp:!='
        LT='regexp:<'
        GT='regexp:>'
        LTE='regexp:<='
        GTE='regexp:>='

        // Boolean operators
        ANDAND='regexp:&&'
        OROR='regexp:\|\|'
        NOT='regexp:!'


        // Arithmetic operators
        PLUS='regexp:\+'
        MINUS='regexp:-'
        STAR='regexp:\*'
        DIV='regexp:/'
        MOD='regexp:%'
        REMAINDER='regexp:%%'

        // Bitwise operators
        AND_BITWISE='regexp:&'
        OR_BITWISE='regexp:\|'
        XOR_BITWISE='regexp:~'
        LSHIFT='regexp:<<'
        RSHIFT='regexp:>>'


        // Assignment operators
        PLUS_EQ='regexp:\+='
        MINUS_EQ='regexp:-='
        STAR_EQ='regexp:\*='
        DIV_EQ='regexp:/='
        MOD_EQ='regexp:%='
        REMAINDER_EQ='regexp:%%='
        AND_EQ='regexp:&='
        OR_EQ='regexp:\|='
        XOR_EQ='regexp:~='
        ANDAND_EQ='regexp:&&='
        OROR_EQ='regexp:\|\|='
        LSHIFT_EQ='regexp:<<='
        RSHIFT_EQ='regexp:>>='

        // Range Operators
        RANGE = 'regexp:\.\.'
        RANGE_INCLUSIVE='regexp:\.\.='
        RANGE_EXCLUSIVE='regexp:\.\.<'

        WHITE_SPACE='regexp:\s+|\r?\n'

  ]

  extends('.*_expression') = expression
}

odinFile ::= packageDeclaration globalStatement*
packageDeclaration ::= PACKAGE IDENTIFIER
importDeclaration ::= IMPORT IDENTIFIER? DQ_STRING_LITERAL

globalStatement ::= importDeclaration | structDeclaration | statement

statement  ::= variableAssignmentDeclaration
| variableDeclaration
| constantAssigment
| procedureDeclaration
| forStatement
| ifStatement
| switchStatement
| deferStatement

// Struct
structDeclaration ::= IDENTIFIER COLON COLON STRUCT LBRACE (variableDeclaration COMMA)* RBRACE

// Procedure
procedureDeclaration ::= IDENTIFIER COLON COLON PROC LPAREN parameterList* RPAREN (ARROW returnType)?
                         procedureBody

procedureBody ::= LBRACE statementsAllowedInProcedure* RBRACE
statementsAllowedInProcedure ::= statementAllowedInBlock|returnStatement

returnType ::= IDENTIFIER
            | LPAREN parameterList* RPAREN

returnStatement ::= RETURN argumentList?

// Variables and constants
typeIdentifier ::= (LBRACKET (INTEGER_DEC_LITERAL|IDENTIFIER)? RBRACKET)? IDENTIFIER
constantAssigment ::= IDENTIFIER COLON typeIdentifier? COLON expression
variableAssignmentDeclaration ::= (typelessParameterList COLON EQ | IDENTIFIER COLON typeIdentifier EQ) expression
variableAssignment ::= IDENTIFIER assignmentOperator expression
assignmentOperator ::= EQ
                       | PLUS_EQ
                       | MINUS_EQ
                       | STAR_EQ
                       | DIV_EQ
                       | MOD_EQ
                       | REMAINDER_EQ
                       | AND_EQ
                       | OR_EQ
                       | XOR_EQ
                       | ANDAND_EQ
                       | OROR_EQ
                       | LSHIFT_EQ
                       | RSHIFT_EQ

variableDeclaration ::= IDENTIFIER COLON typeIdentifier


// Parameters for procedures and assignments
typelessParameterList ::= IDENTIFIER (COMMA IDENTIFIER)*
parameterList ::= parameter (COMMA parameter)*
parameter ::= IDENTIFIER (COLON IDENTIFIER)?

// Expressions
argumentList ::= expression (COMMA expression)*
functionCall_expression ::= expression LPAREN argumentList* RPAREN

binary_expression ::= expression binaryOperator expression
binaryOperator ::= PLUS
                   | MINUS
                   | STAR
                   | DIV
                   | MOD
                   | REMAINDER
                   | AND_BITWISE
                   | OR_BITWISE
                   | XOR_BITWISE
                   | ANDAND
                   | OROR
                   | LSHIFT
                   | RSHIFT
                   | EQEQ
                   | NEQ
                   | LT
                   | GT
                   | LTE
                   | GTE
                   | RANGE_INCLUSIVE
                   | RANGE_EXCLUSIVE
                   | RANGE

parenthesized_expression ::= LPAREN expression RPAREN

// Does it make sense to have literal expressions in the chain?

expression ::= parenthesized_expression
               | chain_expression
               | functionCall_expression
               | literal_expression
               | binary_expression
               | fixedArray_expression
               | arraySlice_expression
               | arrayIndex_expression
               | identifier_expression

identifier_expression ::= IDENTIFIER
chain_expression ::= expression (DOT expression)

string_literal ::= DQ_STRING_LITERAL
integer_literal ::= INTEGER_DEC_LITERAL
                    | INTEGER_HEX_LITERAL
                    | INTEGER_OCT_LITERAL

boolean_literal ::= TRUE
                    | FALSE

literal_expression ::= string_literal
         | integer_literal
         | boolean_literal

fixedArray_expression ::= LBRACKET (INTEGER_DEC_LITERAL|QUESTION) RBRACKET LBRACE expression (COMMA expression)* RBRACE
arrayIndex_expression ::= expression LBRACKET expression RBRACKET
arraySlice_expression ::= expression LBRACKET expression? COLON expression? RBRACKET

directive ::= HASH IDENTIFIER

forStatement ::= directive? forHead forBody
forHead ::= forIn|forTraditional
forBody ::= forBlock | forSingleStatement
forBlock ::= LBRACE (statementAllowedInBlock)* RBRACE
forSingleStatement ::= DO statementAllowedInBlock

// Statements that are allowed in "blocks" like for loops, if statements, etc.
statementAllowedInBlock ::= statement|variableAssignment|expression

forTraditional ::= FOR (forStartStatement? SEMICOLON)? expression? (SEMICOLON forEndStatement?)?
forIn ::= FOR IDENTIFIER (COMMA IDENTIFIER)* IN expression

private forStartStatement ::=   variableAssignmentDeclaration | variableAssignment | functionCall_expression
private forEndStatement ::=   variableAssignment | functionCall_expression

ifStatement ::= IF  ifHead ifBlock (elseIfBlock)* (elseBlock)?
ifHead ::=  (variableAssignmentDeclaration (COMMA variableAssignmentDeclaration)* SEMICOLON)? expression
ifBlock ::= LBRACE (statementAllowedInBlock)* RBRACE
elseIfBlock ::= ELSE IF ifHead ifBlock
elseBlock ::= ELSE ifBlock

switchStatement ::= SWITCH ifHead? LBRACE (switchCaseBlock)* RBRACE
switchCaseBlock ::= CASE (expression(COMMA expression)*)? COLON (statementAllowedInBlock|FALLTHROUGH)*

deferStatement ::= DEFER expression|ifStatement|forStatement|switchStatement